<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Islamic Prayer Times World Map</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: #1a1a2e;
            color: #eee;
        }

        header {
            background-color: #16213e;
            padding: 15px 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            z-index: 1001;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #4a90e2;
        }

        #controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 12px;
            color: #bbb;
        }

        select, input[type="datetime-local"] {
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid #3a4f6c;
            background-color: #1a1a2e;
            color: #eee;
            font-size: 14px;
            cursor: pointer;
        }

        select:hover, input:hover {
            border-color: #4a90e2;
        }

        #map-container {
            flex: 1;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        #map-canvas {
            width: 100%;
            height: 100%;
            display: none;
        }

        #map-canvas.active {
            display: block;
        }

        #map.active {
            display: block;
        }

        #map.hidden {
            display: none;
        }

        #legend {
            position: absolute;
            bottom: 30px;
            right: 10px;
            background-color: rgba(22, 33, 62, 0.95);
            padding: 15px;
            border-radius: 8px;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            min-width: 200px;
        }

        #legend h3 {
            margin-bottom: 10px;
            font-size: 16px;
            border-bottom: 2px solid #4a90e2;
            padding-bottom: 5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 14px;
        }

        .legend-color {
            width: 30px;
            height: 20px;
            margin-right: 10px;
            border-radius: 3px;
            border: 1px solid #333;
        }

        #time-display {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(22, 33, 62, 0.95);
            padding: 10px 15px;
            border-radius: 8px;
            z-index: 1000;
            font-size: 14px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        button {
            padding: 8px 16px;
            border-radius: 5px;
            border: 1px solid #4a90e2;
            background-color: #4a90e2;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #357abd;
        }

        #time-slider {
            width: 200px;
        }

        .leaflet-container {
            background-color: #1a2332;
        }

        /* Leaflet control customization */
        .leaflet-control-zoom a {
            background-color: rgba(22, 33, 62, 0.9) !important;
            color: #4a90e2 !important;
        }

        .leaflet-control-zoom a:hover {
            background-color: rgba(74, 144, 226, 0.3) !important;
        }
    </style>
</head>
<body>
    <header>
        <h1>ðŸ•Œ Islamic Prayer Times World Map</h1>
        <div id="controls">
            <div class="control-group">
                <label for="map-renderer">Map Renderer:</label>
                <select id="map-renderer">
                    <option value="leaflet">Leaflet + OpenStreetMap (Real Map)</option>
                    <option value="geojson">Embedded GeoJSON (Accurate, Large File)</option>
                    <option value="polygons">Detailed Polygons (Lightweight)</option>
                </select>
            </div>
            <div class="control-group">
                <label for="projection">Map Projection:</label>
                <select id="projection">
                    <option value="mercator">Mercator</option>
                    <option value="equirectangular">Equirectangular</option>
                </select>
            </div>
            <div class="control-group">
                <label for="time-input">Select Time:</label>
                <input type="datetime-local" id="time-input" />
            </div>
            <div class="control-group">
                <label for="time-slider">Time Slider (hours):</label>
                <input type="range" id="time-slider" min="0" max="23.5" step="0.5" value="12" />
            </div>
            <div class="control-group">
                <label for="asr-method">Asr Calculation:</label>
                <select id="asr-method">
                    <option value="standard">Standard (Shafi'i, Maliki, Hanbali)</option>
                    <option value="hanafi">Hanafi</option>
                </select>
            </div>
            <div class="control-group">
                <label for="calculation-method">Calculation Method:</label>
                <select id="calculation-method">
                    <option value="mwl">Muslim World League</option>
                    <option value="isna">Islamic Society of North America (ISNA)</option>
                    <option value="egypt">Egyptian General Authority</option>
                    <option value="makkah">Umm Al-Qura University, Makkah</option>
                    <option value="karachi">University of Islamic Sciences, Karachi</option>
                    <option value="tehran">Institute of Geophysics, University of Tehran</option>
                </select>
            </div>
            <button id="update-btn">Update Map</button>
        </div>
    </header>
    <div id="map-container">
        <div id="map" class="active"></div>
        <canvas id="map-canvas"></canvas>
        <div id="time-display">Loading...</div>
        <div id="legend">
            <h3>Prayer Zones</h3>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #1a237e;"></div>
                <span>Fajr</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #f57c00;"></div>
                <span>Ishraq</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #fdd835;"></div>
                <span>Dhuhr</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #43a047;"></div>
                <span>Asr</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #e53935;"></div>
                <span>Maghrib</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #6a1b9a;"></div>
                <span>Isha</span>
            </div>
        </div>
    </div>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    
    <script>
        // Prayer time calculation parameters
        const calculationMethods = {
            mwl: { fajr: 18, isha: 17, maghrib: '0 min', midnight: 'Standard' },
            isna: { fajr: 15, isha: 15, maghrib: '0 min', midnight: 'Standard' },
            egypt: { fajr: 19.5, isha: 17.5, maghrib: '0 min', midnight: 'Standard' },
            makkah: { fajr: 18.5, isha: '90 min', maghrib: '0 min', midnight: 'Standard' },
            karachi: { fajr: 18, isha: 18, maghrib: '0 min', midnight: 'Standard' },
            tehran: { fajr: 17.7, isha: 14, maghrib: '4.5', midnight: 'Jafari' }
        };

        // Map state
        let map;
        let prayerOverlay;
        let selectedTime = new Date();
        let currentRenderer = 'leaflet';
        let canvas, ctx;
        let zoom = 1.5;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let lastX, lastY;

        // Detailed world boundaries for polygon renderer
        const worldBoundaries = [
            // Africa
            [[37, -17], [35, -12], [32, -6], [33, 0], [37, 11], [35, 18], [31, 27], [28, 31], [22, 32], 
             [15, 43], [12, 51], [8, 51], [4, 51], [-4, 40], [-10, 40], [-15, 36], [-20, 35], [-26, 32], 
             [-29, 28], [-33, 24], [-34, 18], [-34, 27], [-30, 31], [-26, 33], [-22, 35], [-17, 25], 
             [-12, 13], [4, 9], [10, 8], [11, -3], [8, -8], [5, -9], [10, -12], [15, -13], [22, -16], 
             [28, -17], [32, -17], [37, -17]],
            // Europe
            [[71, 26], [70, 60], [68, 62], [61, 68], [58, 60], [55, 50], [53, 48], [48, 50], [45, 45], 
             [43, 42], [40, 20], [38, 12], [36, 6], [36, -9], [38, -9], [43, -9], [48, -7], [50, -5], 
             [55, -2], [59, -4], [60, 5], [63, 10], [69, 18], [71, 26]],
            // Asia  
            [[77, 104], [75, 90], [73, 80], [68, 75], [60, 73], [53, 73], [47, 68], [41, 60], [35, 52], 
             [29, 48], [25, 55], [25, 70], [23, 72], [20, 72], [15, 78], [8, 80], [8, 90], [8, 97], 
             [15, 95], [22, 88], [25, 88], [28, 88], [28, 97], [32, 100], [35, 100], [40, 110], [40, 120], 
             [43, 130], [50, 142], [55, 150], [60, 160], [66, 170], [70, 180], [73, -175], [73, -170], 
             [68, -168], [65, -170], [61, -165], [55, -175], [51, -180], [70, 180], [77, 104]],
            // North America
            [[83, -60], [80, -70], [72, -80], [71, -96], [68, -120], [60, -165], [58, -150], [55, -130], 
             [52, -125], [48, -123], [40, -120], [32, -117], [28, -110], [25, -97], [30, -81], [28, -80], 
             [25, -80], [20, -77], [18, -77], [15, -87], [18, -95], [25, -100], [28, -97], [35, -95], 
             [42, -85], [48, -67], [52, -65], [60, -64], [65, -65], [70, -70], [72, -60], [75, -60], 
             [83, -60]],
            // South America
            [[12, -71], [10, -75], [8, -79], [0, -80], [-5, -81], [-12, -77], [-18, -70], [-25, -70], 
             [-33, -71], [-40, -72], [-48, -70], [-55, -67], [-55, -65], [-48, -65], [-40, -62], [-34, -58], 
             [-28, -48], [-22, -43], [-23, -44], [-18, -48], [-12, -49], [-3, -49], [0, -55], [5, -61], 
             [10, -70], [11, -73], [12, -71]],
            // Australia
            [[-10, 142], [-15, 145], [-25, 150], [-35, 150], [-38, 148], [-39, 146], [-38, 140], [-35, 135], 
             [-34, 115], [-28, 113], [-20, 114], [-15, 125], [-12, 130], [-10, 142]]
        ];

        // Simplified GeoJSON data (for geojson renderer)
        const worldGeoJSON = {
            "type": "FeatureCollection",
            "features": [
                {
                    "type": "Feature",
                    "properties": {"name": "Africa"},
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [worldBoundaries[0].map(p => [p[1], p[0]])]
                    }
                },
                {
                    "type": "Feature",
                    "properties": {"name": "Europe"},
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [worldBoundaries[1].map(p => [p[1], p[0]])]
                    }
                },
                {
                    "type": "Feature",
                    "properties": {"name": "Asia"},
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [worldBoundaries[2].map(p => [p[1], p[0]])]
                    }
                },
                {
                    "type": "Feature",
                    "properties": {"name": "North America"},
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [worldBoundaries[3].map(p => [p[1], p[0]])]
                    }
                },
                {
                    "type": "Feature",
                    "properties": {"name": "South America"},
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [worldBoundaries[4].map(p => [p[1], p[0]])]
                    }
                },
                {
                    "type": "Feature",
                    "properties": {"name": "Australia"},
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [worldBoundaries[5].map(p => [p[1], p[0]])]
                    }
                }
            ]
        };

        // Initialize Leaflet map with real OpenStreetMap tiles
        function initLeafletMap() {
            if (map) {
                map.remove();
            }
            
            document.getElementById('map').classList.add('active');
            document.getElementById('map').classList.remove('hidden');
            document.getElementById('map-canvas').style.display = 'none';
            
            map = L.map('map', {
                center: [20, 0],
                zoom: 2,
                minZoom: 2,
                maxZoom: 8,
                worldCopyJump: true
            });

            // Add OpenStreetMap tiles - REAL map data
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: 19
            }).addTo(map);

            // Update prayer zones when map moves or zooms
            map.on('moveend', updatePrayerZonesLeaflet);
            map.on('zoomend', updatePrayerZonesLeaflet);
        }

        // Initialize Canvas-based map with GeoJSON
        function initGeoJSONMap() {
            if (map) {
                map.remove();
                map = null;
            }
            
            document.getElementById('map').classList.add('hidden');
            document.getElementById('map').classList.remove('active');
            document.getElementById('map-canvas').style.display = 'block';
            
            canvas = document.getElementById('map-canvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            
            setupCanvasEvents();
        }

        // Initialize Canvas-based map with detailed polygons
        function initPolygonMap() {
            if (map) {
                map.remove();
                map = null;
            }
            
            document.getElementById('map').classList.add('hidden');
            document.getElementById('map').classList.remove('active');
            document.getElementById('map-canvas').style.display = 'block';
            
            canvas = document.getElementById('map-canvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            
            setupCanvasEvents();
        }

        function resizeCanvas() {
            const container = document.getElementById('map-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        function setupCanvasEvents() {
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const dx = e.clientX - lastX;
                    const dy = e.clientY - lastY;
                    offsetX += dx;
                    offsetY += dy;
                    lastX = e.clientX;
                    lastY = e.clientY;
                    drawCanvasMap();
                }
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });

            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
            });

            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                zoom *= delta;
                if (zoom < 0.5) zoom = 0.5;
                if (zoom > 10) zoom = 10;
                drawCanvasMap();
            });
        }

        // Calculate solar position
        function calculateSolarPosition(date, longitude) {
            const J2000 = 2451545.0;
            const jd = date.getTime() / 86400000 + 2440587.5;
            const n = jd - J2000;
            const L = (280.460 + 0.9856474 * n) % 360;
            const g = (357.528 + 0.9856003 * n) % 360;
            const gRad = g * Math.PI / 180;
            const lambda = (L + 1.915 * Math.sin(gRad) + 0.020 * Math.sin(2 * gRad)) % 360;
            const epsilon = 23.439 - 0.0000004 * n;
            const epsilonRad = epsilon * Math.PI / 180;
            const lambdaRad = lambda * Math.PI / 180;
            
            const declination = Math.asin(Math.sin(epsilonRad) * Math.sin(lambdaRad)) * 180 / Math.PI;
            const eot = 4 * (L - Math.atan2(Math.cos(epsilonRad) * Math.sin(lambdaRad), Math.cos(lambdaRad)) * 180 / Math.PI);
            const solarNoon = 12 - longitude / 15 - eot / 60;
            
            return { declination, eot, solarNoon };
        }

        // Calculate prayer times for a location
        function calculatePrayerTimes(lat, lng, date, method, asrMethod) {
            const params = calculationMethods[method];
            const { declination, solarNoon } = calculateSolarPosition(date, lng);
            
            const latRad = lat * Math.PI / 180;
            const declRad = declination * Math.PI / 180;
            
            function hourAngle(angle) {
                const angleRad = angle * Math.PI / 180;
                const cosH = (Math.sin(angleRad) - Math.sin(latRad) * Math.sin(declRad)) / 
                             (Math.cos(latRad) * Math.cos(declRad));
                if (cosH > 1 || cosH < -1) return null;
                return Math.acos(cosH) * 180 / Math.PI;
            }
            
            const fajrAngle = typeof params.fajr === 'number' ? -params.fajr : -18;
            const fajrHA = hourAngle(fajrAngle);
            const fajr = fajrHA ? solarNoon - fajrHA / 15 : null;
            
            const sunriseHA = hourAngle(-0.833);
            const sunrise = sunriseHA ? solarNoon - sunriseHA / 15 : null;
            
            const dhuhr = solarNoon;
            
            const asrFactor = asrMethod === 'hanafi' ? 2 : 1;
            const asrAltitude = Math.atan(1 / (asrFactor + Math.tan(Math.abs(latRad - declRad)))) * 180 / Math.PI;
            const asrHA = hourAngle(asrAltitude);
            const asr = asrHA ? solarNoon + asrHA / 15 : null;
            
            const maghribHA = hourAngle(-0.833);
            const maghrib = maghribHA ? solarNoon + maghribHA / 15 : null;
            
            let isha;
            if (typeof params.isha === 'number') {
                const ishaAngle = -params.isha;
                const ishaHA = hourAngle(ishaAngle);
                isha = ishaHA ? solarNoon + ishaHA / 15 : null;
            } else {
                isha = maghrib ? maghrib + 1.5 : null;
            }
            
            return { fajr, sunrise, dhuhr, asr, maghrib, isha };
        }

        // Determine which prayer time is active at a location
        function getCurrentPrayer(lat, lng, date, method, asrMethod) {
            const times = calculatePrayerTimes(lat, lng, date, method, asrMethod);
            
            const utcHours = date.getUTCHours() + date.getUTCMinutes() / 60;
            const localSolarTime = (utcHours + lng / 15 + 24) % 24;
            
            if (times.fajr === null || times.sunrise === null) {
                return 'isha';
            }
            
            let fajr = (times.fajr + 24) % 24;
            let sunrise = (times.sunrise + 24) % 24;
            let dhuhr = (times.dhuhr + 24) % 24;
            let asr = (times.asr + 24) % 24;
            let maghrib = (times.maghrib + 24) % 24;
            let isha = (times.isha + 24) % 24;
            
            if (localSolarTime >= fajr && localSolarTime < sunrise) {
                return 'fajr';
            } else if (localSolarTime >= sunrise && localSolarTime < dhuhr) {
                return 'ishraq';
            } else if (localSolarTime >= dhuhr && localSolarTime < asr) {
                return 'dhuhr';
            } else if (localSolarTime >= asr && localSolarTime < maghrib) {
                return 'asr';
            } else if (localSolarTime >= maghrib && localSolarTime < isha) {
                return 'maghrib';
            } else {
                return 'isha';
            }
        }

        // Map projection functions
        function latLngToXY(lat, lng) {
            const x = (lng + 180) / 360;
            const latRad = lat * Math.PI / 180;
            const mercN = Math.log(Math.tan(Math.PI / 4 + latRad / 2));
            const y = 0.5 - mercN / (2 * Math.PI);
            return { x, y };
        }

        function xyToLatLng(x, y) {
            const lng = x * 360 - 180;
            const mercN = (0.5 - y) * 2 * Math.PI;
            const latRad = 2 * Math.atan(Math.exp(mercN)) - Math.PI / 2;
            const lat = latRad * 180 / Math.PI;
            return { lat, lng };
        }

        // Draw canvas-based map
        function drawCanvasMap() {
            const method = document.getElementById('calculation-method').value;
            const asrMethod = document.getElementById('asr-method').value;

            const prayerColors = {
                'fajr': '#1a237e',
                'ishraq': '#f57c00',
                'dhuhr': '#fdd835',
                'asr': '#43a047',
                'maghrib': '#e53935',
                'isha': '#6a1b9a'
            };

            // Clear canvas
            ctx.fillStyle = '#1a2332';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2 + offsetX;
            const centerY = canvas.height / 2 + offsetY;

            // Draw prayer zones
            const pixelSize = 2;
            for (let px = 0; px < canvas.width; px += pixelSize) {
                for (let py = 0; py < canvas.height; py += pixelSize) {
                    const worldX = (px - centerX) / (canvas.width * zoom / 2);
                    const worldY = (py - centerY) / (canvas.height * zoom / 2);
                    
                    const normX = worldX + 0.5;
                    const normY = worldY + 0.5;
                    
                    if (normX < 0 || normX > 1 || normY < 0 || normY > 1) continue;
                    
                    const { lat, lng } = xyToLatLng(normX, normY);
                    
                    if (lat < -85 || lat > 85) continue;
                    
                    const prayer = getCurrentPrayer(lat, lng, selectedTime, method, asrMethod);
                    ctx.fillStyle = prayerColors[prayer];
                    ctx.globalAlpha = 0.6;
                    ctx.fillRect(px, py, pixelSize, pixelSize);
                }
            }
            ctx.globalAlpha = 1.0;

            // Draw land boundaries
            ctx.fillStyle = '#2d3e50';
            ctx.strokeStyle = '#1a252f';
            ctx.lineWidth = 1;
            
            worldBoundaries.forEach(boundary => {
                ctx.beginPath();
                let firstPoint = true;
                boundary.forEach(([lat, lng]) => {
                    const { x, y } = latLngToXY(lat, lng);
                    const screenX = (x - 0.5) * canvas.width * zoom + centerX;
                    const screenY = (y - 0.5) * canvas.height * zoom + centerY;
                    if (firstPoint) {
                        ctx.moveTo(screenX, screenY);
                        firstPoint = false;
                    } else {
                        ctx.lineTo(screenX, screenY);
                    }
                });
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            });

            updateTimeDisplay();
        }

        // Update prayer zones overlay on Leaflet map
        function updatePrayerZonesLeaflet() {
            const method = document.getElementById('calculation-method').value;
            const asrMethod = document.getElementById('asr-method').value;

            const prayerColors = {
                'fajr': 'rgba(26, 35, 126, 0.5)',
                'ishraq': 'rgba(245, 124, 0, 0.5)',
                'dhuhr': 'rgba(253, 216, 53, 0.5)',
                'asr': 'rgba(67, 160, 71, 0.5)',
                'maghrib': 'rgba(229, 57, 53, 0.5)',
                'isha': 'rgba(106, 27, 154, 0.5)'
            };

            // Remove existing overlay
            if (prayerOverlay) {
                map.removeLayer(prayerOverlay);
            }

            // Get map bounds and size
            const bounds = map.getBounds();
            const size = map.getSize();
            
            // Create canvas for prayer zones
            const canvas = document.createElement('canvas');
            canvas.width = size.x;
            canvas.height = size.y;
            const ctx = canvas.getContext('2d');

            // Render prayer zones - sample every 2 pixels for balance between performance and quality
            const pixelStep = 2;
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            
            for (let x = 0; x < canvas.width; x += pixelStep) {
                for (let y = 0; y < canvas.height; y += pixelStep) {
                    const point = map.containerPointToLatLng([x, y]);
                    const lat = point.lat;
                    let lng = point.lng;
                    
                    // Normalize longitude to -180 to 180
                    while (lng > 180) lng -= 360;
                    while (lng < -180) lng += 360;
                    
                    if (lat < -85 || lat > 85) continue;
                    
                    const prayer = getCurrentPrayer(lat, lng, selectedTime, method, asrMethod);
                    const color = prayerColors[prayer];
                    
                    // Parse RGBA color
                    const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),?\s*([\d.]+)?\)/);
                    if (match) {
                        const r = parseInt(match[1]);
                        const g = parseInt(match[2]);
                        const b = parseInt(match[3]);
                        const a = match[4] ? parseFloat(match[4]) * 255 : 255;
                        
                        // Fill the pixel block
                        for (let dx = 0; dx < pixelStep && x + dx < canvas.width; dx++) {
                            for (let dy = 0; dy < pixelStep && y + dy < canvas.height; dy++) {
                                const idx = ((y + dy) * canvas.width + (x + dx)) * 4;
                                imageData.data[idx] = r;
                                imageData.data[idx + 1] = g;
                                imageData.data[idx + 2] = b;
                                imageData.data[idx + 3] = a;
                            }
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Add canvas as image overlay on top of the real map
            const imageUrl = canvas.toDataURL();
            prayerOverlay = L.imageOverlay(imageUrl, bounds, {
                opacity: 0.6,
                interactive: false
            }).addTo(map);

            updateTimeDisplay();
        }

        function updateTimeDisplay() {
            const display = document.getElementById('time-display');
            const options = { 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric', 
                hour: '2-digit', 
                minute: '2-digit',
                timeZone: 'UTC',
                timeZoneName: 'short'
            };
            display.textContent = selectedTime.toLocaleString('en-US', options);
        }

        // Unified update function
        function updatePrayerZones() {
            if (currentRenderer === 'leaflet') {
                updatePrayerZonesLeaflet();
            } else {
                drawCanvasMap();
            }
        }

        function updateFromTimeInput() {
            const timeInput = document.getElementById('time-input');
            if (timeInput.value) {
                selectedTime = new Date(timeInput.value);
            }
            updatePrayerZones();
        }

        function updateFromSlider() {
            const slider = document.getElementById('time-slider');
            const hours = parseFloat(slider.value);
            const now = new Date();
            selectedTime = new Date(Date.UTC(
                now.getUTCFullYear(), 
                now.getUTCMonth(), 
                now.getUTCDate(), 
                Math.floor(hours), 
                (hours % 1) * 60
            ));
            
            const timeInput = document.getElementById('time-input');
            const pad = (n) => n.toString().padStart(2, '0');
            timeInput.value = `${selectedTime.getUTCFullYear()}-${pad(selectedTime.getUTCMonth() + 1)}-${pad(selectedTime.getUTCDate())}T${pad(selectedTime.getUTCHours())}:${pad(selectedTime.getUTCMinutes())}`;
            
            updatePrayerZones();
        }

        function switchRenderer() {
            const renderer = document.getElementById('map-renderer').value;
            currentRenderer = renderer;
            
            if (renderer === 'leaflet') {
                initLeafletMap();
                setTimeout(() => updatePrayerZonesLeaflet(), 1000);
            } else if (renderer === 'geojson') {
                initGeoJSONMap();
                drawCanvasMap();
            } else if (renderer === 'polygons') {
                initPolygonMap();
                drawCanvasMap();
            }
        }

        function initializeTime() {
            const now = new Date();
            selectedTime = now;
            
            const timeInput = document.getElementById('time-input');
            const pad = (n) => n.toString().padStart(2, '0');
            timeInput.value = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}T${pad(now.getHours())}:${pad(now.getMinutes())}`;
            
            const slider = document.getElementById('time-slider');
            slider.value = now.getUTCHours() + now.getUTCMinutes() / 60;
        }

        // Event listeners
        document.getElementById('update-btn').addEventListener('click', updatePrayerZones);
        document.getElementById('time-input').addEventListener('change', updateFromTimeInput);
        document.getElementById('time-slider').addEventListener('input', updateFromSlider);
        document.getElementById('map-renderer').addEventListener('change', switchRenderer);
        
        document.getElementById('projection').addEventListener('change', (e) => {
            if (e.target.value === 'equirectangular') {
                alert('Note: For Equirectangular projection with Leaflet, proj4leaflet library is needed. Mercator is the standard web map projection.');
            }
        });

        // Resize handling for canvas
        window.addEventListener('resize', () => {
            if (currentRenderer !== 'leaflet' && canvas) {
                resizeCanvas();
                drawCanvasMap();
            }
        });

        // Initialize when page loads
        window.addEventListener('load', () => {
            initLeafletMap();
            initializeTime();
            // Delay initial render to ensure map is ready
            setTimeout(() => updatePrayerZonesLeaflet(), 1000);
        });
    </script>
</body>
</html>
